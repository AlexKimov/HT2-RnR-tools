//------------------------------------------------
//--- 010 Editor v8.0.1 Binary Template
//
//      File: RES.bt
//   Authors: Alexandr Evdokimov
//   Version: 0.2
//   Purpose: Hard truck 2 RES file
//
//   History: 
//    
//   2018.05 v 0.1 initial release 
//
//------------------------------------------------

local uint count;
local uint passthrough = 0;

uint getNumber(string Str) {
  local uint pos = 0, count = 0;
  local string S;
  pos = Strchr(Str, ' ');
  S = SubStr(Str, pos + 1, Strlen(Str) - pos);
  if (SScanf(S, "%d", count) > 0)
    return count;
  else
    return 1;
}

uint blockCount(uint width) {
  return Floor(width/127);
}

string getID(string Str) {
  local uint pos = 0;
  local string S;
  pos = Strchr(Str, ' ');
  return SubStr(Str, 0, pos);
}

typedef enum <char> {
  PFRM,
  LVMP,
  ENDR,
  MS16,
  MASK,
  PALT
} IDENTIFIER;

typedef struct {
  UINT SectionSize;
  UINT type;
  UINT Width;
  UINT Height; 
  UINT HS; 
  local uint w,h;
  w = Width; h = Height;
  while (w >= 1) {
    typedef struct {  
      UBYTE Blue: 5;
      UBYTE Green: 5;
      UBYTE Red: 5;
      UBYTE Alpha: 1;
    } PIXEL_RGB16; 
    typedef struct (int arraySize) {
      PIXEL_RGB16 array[arraySize];
    } PIXEL_RGB16_Array; 
    PIXEL_RGB16_Array Pixels(w*h);
    w = w/2; h = h/2;
  };
  BYTE A[2];  
} LVMP;

typedef struct {
  BYTE B[40];
} PFRM;

BitfieldDisablePadding(); 

typedef struct {
  WORD W;
  WORD H;
  BYTE A[768]; // empty
  
  if (W > H) {
    local uint blockCount;
    blockCount = 1;
 
    if (W > 127)
      blockCount = blockCount(W);
      
    typedef struct {
      UBYTE Count;
      if (Count > 127) 
        UBYTE Count;
      struct {
         UBYTE Blue:  5;
         UBYTE Green: 5;
         UBYTE Red:   5;
         UBYTE Alpha: 1;
      } PXL[Count] <optimize=false>;
      if (Count < 127) UBYTE U;
    } BLOCK <optimize=false, name="Block">; 

    typedef struct (int arraySize) {
      BLOCK array[arraySize] <optimize=false>;
    } BLOCK_Array;       
    BLOCK_Array Pixels(589) <name="Blocks">;
  } else {
    struct {
       UBYTE Blue:  5;
       UBYTE Green: 5;
       UBYTE Red:   5;
       UBYTE Alpha: 1;
    } PXL[W*H] <optimize=false>; 
    BYTE A;   
  };
//  if (U != 129) FSeek(FTell() - 1);  

  PFRM pfrmid;
  UINT A;
} MS16 <optimize=false>;

typedef struct {
  struct {
    WORD W;
    WORD H;
  } HEADER;
  
  struct {
    BYTE A;
    BYTE B;
    BYTE C;
  } O[256];

  typedef struct {  
    UBYTE Color;
  } P <size=1, name="Pixel", optimize=false>;
  typedef struct (int arraySize) {
    P array[arraySize];
  } P_Array;       
  P_Array Ps(HEADER.W*HEADER.H) <name="Ps">;
 
} MASK <optimize=false>;

typedef struct { 
  string FileName;
  UINT SectionSize;   
  IDENTIFIER identifier[4];
  if (identifier == "MS16") {
    MS16 m16; 
  } else {
    MASK mask;    
  };
} MS <name=maskFileName, optimize=false>;

string maskFileName(MS &ms) {
  return ms.FileName;
}

typedef struct {
    string Name;
} ID <name = idName>;

string idName(ID &id) {
  return "ID: " + id.Name;
}

typedef struct {
  string Name;
} NAME <name=Name>; 
typedef struct (int arraySize) {
  NAME array[arraySize] <optimize=false>;
} NAME_ARRAY;  

string Name(NAME &n) {
  return n.Name;
}     


local uint i = 0;
local string idname;
while (!FEof()) {
  ID identifier;
  idname = getID(identifier.Name);

  switch (idname) {
    case "COLORS": 
        count = getNumber(identifier.Name);             
        NAME_ARRAY Colors(count) <name="Colors">;
        break;
    case "TEXTUREFILES":
        count = getNumber(identifier.Name);         
        typedef struct {
          struct {
            string FileName;
            UINT SectionSize;  
          
            UBYTE  IDLength;
            UBYTE  ColorMapType;
            UBYTE  ImageType;
            WORD   FirstIndexEntry;
            WORD   ColorMapLength;
            UBYTE  ColorMapEntrySize; 
        
            WORD   XOrigin;
            WORD   YOrigin;
            WORD   Width;
            WORD   Height;
            UBYTE  PixelDepth;
            UBYTE  ImageDescriptor;
        
            char Name[4]; // Line Offset
            UINT LineOffset;
            UINT SizeImage;
          } TGAHEADER;
        
          //struct {  
         //   UBYTE Blue:  5;
          //  UBYTE Green: 5;
         //   UBYTE Red:   5;
         //   UBYTE Alpha: 1;
         // } RGB16[HEADER.Width*HEADER.Height] <size=2>;
          
         FSeek(FTell() + 2*TGAHEADER.Width*TGAHEADER.Height);
        
          IDENTIFIER id[4];
          if (id == "LVMP") {
            LVMP lvmpid;
            PFRM pfrmid;
            UINT V;
          } else {
            PFRM pfrmid;
          };
        } TXR <optimize=false>;
        typedef struct (int arraySize) {
          TXR array[arraySize] <optimize=false>;
        } TXR_Array;       
        TXR_Array TXRs(count) <name="Texture files">;
        break;
    case "PALETTEFILES":
        count = getNumber(identifier.Name); 
        struct {
          string FileName;
          UINT DataSize;
          char PLM[4];
          UINT DataSize;
          IDENTIFIER id[4];
          UINT Size; // 768
          struct {
            UBYTE Red;
            UBYTE Green;
            UBYTE Blue;      
          } COLOR[256];
        } PALETTE[count] <optimize=false>;
        break;
    case "SOUNDFILES": 
        count = getNumber(identifier.Name); 
        typedef struct {
          string FileName;
          UINT DataSize;
          struct {
            char groupID[4]; // RIFF
            long size;
            char riffType[4]; // WAVE
          } WAVRIFFHEADER;    
          FSkip(WAVRIFFHEADER.size - 4);
        } SOUNDFILE <optimize=false>;
        typedef struct (int arraySize) {
          SOUNDFILE array[arraySize] <optimize=false>;
        } SOUNDFILE_Array;       
        SOUNDFILE_Array SoundFiles(count) <name="SoundFiles">;
        break;
    case "BACKFILES":
        break;
    case "MASKFILES":
        count = getNumber(identifier.Name); 
        MS Masks[count] <name="Masks">;
        break;
    case "MATERIALS":
        count = getNumber(identifier.Name);        
        NAME_ARRAY Files(count) <name="Materials">;
        break; 
    case "SOUNDS":
        count = getNumber(identifier.Name); 
        NAME_ARRAY Sounds(count) <name="Sounds">;    
        break;
  };
};