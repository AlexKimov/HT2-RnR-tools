//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: B3D.bt
//   Authors: Alexandr Evdokimov
//   Version: 0.2
//   Purpose: Hard truck 1/2 B3D file
//
//   History: 
//    
//   2018.06 v 0.2 added Hard Truck 1 structures
//   2018.05 v 0.1 initial release 
//
//------------------------------------------------

string IntToStr (uint i) {
  local string s;
  SPrintf(s, "%d", i);
  return s;
} 

void checkIdentifier() {
  while (true) { 
    UINT T <hidden=true>;
    if (T != 444) {
      FSeek(FTell() - 4);
      break; 
    };
  }
}

typedef struct {
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } X;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Y;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Z;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Pos; 
} TRANSFORMATION_MATRIX <name="Transformation matrix">;

typedef enum <uint> {
  Begin_Chunks = 111,
  End_Chunks = 222,
  Begin_Chunk = 333,
  Fours = 444,
  End_Chunk = 555
} IDENTIFIER <name="Identifier">; 

struct {
  char B3D[4] <name="b3D signature">;
  struct {
    UINT FileSize; // 1/4*filesize
    UINT MN; // 6
    UINT MatListDataSize; // 1/4*(materials list data)
    UINT MatHeaderSectionSize; // 1/4*(materials list data + data sizes block)
    UINT ChunksSectionSize; // 1/4*(datasize)
  } DataSizes <name = "Data sizes">;
} Header <name="File Header">;

struct {
    UINT MaterialCount <name="Count">;
    typedef struct {
      char String[32] <name="Name">; 
    } MATERIAL <optimize=false, name=MatName>;
    typedef struct (int arraySize) {
      MATERIAL array[arraySize] <optimize=false>;
    } MATERIAL_Array;       
    MATERIAL_Array Materials(MaterialCount) <name="Materials">;
} M <name="Material List">;

string MatName(MATERIAL &material) {
  return material.String;
};

UINT chunkTree(UINT ChildCount) {
  typedef struct {
    checkIdentifier(); 
    IDENTIFIER Identifier;
    struct {
      char String[32] <name="Name">;
      UINT ID <name="Chunk ID">;
    } HEADER <name="Header">;

    switch ( HEADER.ID ) 
    {
        case 0  : {
          FLOAT MN;         
          FLOAT MN; 
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;         
          FLOAT MN;
          FLOAT MN; 
          FLOAT MN;
          FLOAT MN; 
          FLOAT MN; // 1
          FLOAT MN;          
        }; break;

        case 1  : {
          char Name1[32];
          char Name2[32];
        }; break;

        case 2  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
         // sPrintf("AAAAAA    "); 
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;
           
        }; break;

        // id = 3 only in Hard Truck 1
        case 3  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;           
        }; break;

        case 4  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;
          char Name1[32]; 
          char Data[32]; // 0000000...
          if (Data[0] != 0) uPrintf("AAAAAA"); 
          // id = 37 -> id = 8/ id = 20
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;
    
        case 5  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          char GroupName[32] <name="Name">; // name 
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;       
        }; break;

        // Only in Hard Truck 1
        case 6  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          char GroupName[32] <name="Name">; // name 
          char Name[32]; // name 
          UINT Count;   
          typedef struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
          } ARRAY;      
          ARRAY Arr[Count];
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;        
        }; break;

        case 7  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          char GroupName[32]; // name 
          UINT VertexCount <name="Vertex Count">;
          typedef struct { 
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } XYZ;
            struct {
              FLOAT U;
              FLOAT V;
            } UV;
          } VERTEX;
          typedef struct (int arraySize) {
            VERTEX array[arraySize] <optimize=false>;
          } VERTEX_Array;       
          VERTEX_Array Data(VertexCount) <name="DATA">;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;
        }; break;

        case 8  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          UINT Count;
          struct { 
            UINT type2;
            FLOAT MN;
            UINT MN;
            UINT MN;

            UINT CountA;
            if (type2 == 131) {
              struct { 
                UINT MN;
                FLOAT MN;
                FLOAT MN;                
              } H[CountA];                           
            } else
            if (type2 == 129) {
              struct { 
                UINT MN;
              } H[CountA];                           
            } else
            if (type2 == 3) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 176) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 51) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 178) {
              struct { 
                UINT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN; 
                FLOAT MN;  
              } H[CountA] <optimize=false>;                           
            } else
            if (type2 == 179) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 177) {
              struct { 
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 48) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN; 
              } H[CountA];            
            } else {
                if (type2 == 50) {
                   struct { 
                     FLOAT MN;
                     FLOAT MN;
                     FLOAT MN;
                     FLOAT MN; 
                     UINT MN; 
                     UINT MN; 
                   } H[CountA];
                  } else
              UINT L1[CountA] ;
              if (type2 == 2)
                FLOAT L2[CountA*2];                
            }; 
          } K1[Count] <optimize=false>;         
        }; break;

        case 9  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;      
        }; break;

        case 10  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;     
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;             
        }; break;

        // only in Hard Truck 1
        case 11  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;    
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;             
        }; break;

        case 12  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          UINT MN;
          UINT MN;      
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;             
        }; break;

        case 13  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          UINT MN;
          UINT MN;
          UINT Count;
          //if (type1 > 0)
            FLOAT MN1[Count];  
        }; break;

        case 14  : {
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          //asf();   
        }; break;

        // only in Hard Truck 1
        case 16  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
        }; break;

        // only in Hard Truck 1
        case 17  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
        }; break;

        case 18  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
          char Space[32];
          char Object[32];
        }; break;
    
        case 19  : {
            UINT ChildCount;
            chunkTree(ChildCount); 
        }; break;

        case 20  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
            UINT CountA;
            UINT MN;
            UINT MN;
            UINT CountB;
            struct {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;                         
            } Y[CountA];
            FLOAT A[CountB];                   
        }; break;

        case 21  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT MN; 
          UINT MN;
          UINT MN;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;

        case 23  : {
            UINT MN;
            UINT MN;
            UINT type;
            if (type == 3) {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;   
           
              UINT CountA;  
                struct {  
                  UINT Count;

                  struct { 
                    FLOAT MN;
                    FLOAT MN;   
                    FLOAT MN;
                  } L[Count];
                                 
                } L[CountA] <optimize=false>;               
            } else
            if (type == 2) {
              FLOAT MN;
              FLOAT MN;
              UINT CountA;  
                struct {  
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;   
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN; 
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;   
                  FLOAT MN;               
                } L[CountA]; 

            } else {
              UINT CountA; 
              struct {    
                UINT Count;
                struct {  
                    FLOAT MN;
                    FLOAT MN;
                    FLOAT MN;                   
                } L[Count];         
              } K1[CountA] <optimize=false>;
            };   
        }; break;

        case 24  : {
            TRANSFORMATION_MATRIX TM;
            UINT MN; // 0, 1
            //if (MN != 1) Printf(IntToStr(MN));
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;    
        }; break;

        case 25  : {
            FLOAT MN;
            UINT MN;
            UINT MN;
            char Name[32]; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;    
        }; break;

        case 28  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;

            UINT Count;
            struct {
              FLOAT type;
              FLOAT MN;
              UINT A;
              UINT B;
              UINT Count;
              if (type == 4294967040) {
                struct {
                  FLOAT MN; 
                  FLOAT MN;
                } E[Count]; 
              } else 
              struct {
                FLOAT MN; 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } E[Count];
            } Y[Count] <optimize=false>;

            //struct {
            //  UINT ChildCount;
            //  chunkTree(ChildCount);
            //} Children;    
        }; break;

        case 29  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT radius; 
            UINT type; 
            UINT Count;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            if (type != 3)
              FLOAT MN;           
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;    
        }; break;

        case 30  : {
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } ORIGIN;
            FLOAT MN;
            char ConnectedRoom[32];
            struct { 
              struct {
                FLOAT X;
                FLOAT Y;
                FLOAT Z;
              } P1;
              struct {
                FLOAT X;
                FLOAT Y;
                FLOAT Z;
              } P2; 
            } PORTAL;                 
        }; break;

        // only in Hard Truck 1
        case 31  : {
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } ORIGIN;
            FLOAT MN;
            UINT Count;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            UINT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            struct {
              FLOAT MN;
              UINT Count; 
            } Ar[Count];  
        }; break;

        case 33  : {
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } ORIGIN;
            FLOAT MN;
            UINT MN;
            UINT MN;
            UINT MN;
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } POS;
            struct {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
            } Color;
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;  
        }; break;   

        case 34  : {
            struct {
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
            } ORIGIN;
            FLOAT MN;
            FLOAT MN;
            UINT Count;
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
            } K[Count];
            //struct {
            //  UINT ChildCount;
            //  chunkTree(ChildCount);
            //} Children;  
        }; break; 
 
        case 35  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT MN;
          UINT type;
          UINT MIndex;
          UINT MeshCount;

          struct { 
            UINT type1;
            FLOAT MN;
            UINT MN;
            UINT MatIndex;
            UINT Count;

            if (type == 3) {
              UINT Indexes[Count];
            } else
            if (type == 2) {
              if (type1 == 49) {
                struct {
                  UINT MN;
                  FLOAT MN;
                } U[Count];
              } else
              if (type1 == 51) {
                struct {
                  UINT MN;
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;
                }U[Count];
              } else {
                UINT Indexes[Count];
                if (type1 == 3) {
                  UINT MN;
                  FLOAT MN;
                  FLOAT MN;
                  UINT MN;
                  FLOAT MN;
                  UINT MN;
                };
             }; 
           
             } else
              //gfj;
             if (type == 1) {

                if (type1 == 0) {
                  struct {
                    FLOAT MN;
                  } Y[Count];
                } else
                if (type1 == 2) {
                  struct {
                    FLOAT MN;
                    FLOAT MN;
                    FLOAT MN;
                  } Y[Count];
                } else
                struct {
                  UINT Index;
                  FLOAT MN;
                  FLOAT MN; 
                  FLOAT MN; 
                  if (type1 == 50) {
                    UINT MN; 
                    UINT MN; 
                  } ;   
                } Y[Count] <optimize=false>;

            };
          } MESH[MeshCount] <optimize=false>;
        }; break;
 
        case 36  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT MN;
          char Name1[32];
          char Name2[32];
          UINT type;
          UINT Count;
          if (type == 2) {
            struct { 
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
              FLOAT X;
              FLOAT X;
            } K1[Count];
          } else 
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } K1[Count];
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;
        }; break;   

    
        case 37  : {
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } ORIGIN;
          FLOAT MN;
          char Name[32];
          UINT type;
          UINT VertexCount;
          struct {
            if (type == 515) {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN; 
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN;  
            };         
            if (type == 514) {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN; 
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;           
            }; 
            if (type == 258) { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;  
              FLOAT MN;   
            };              
            if (type == 2) {
              struct {     
                FLOAT X;
                FLOAT Y;
                FLOAT Z;
              } COORDINATES;
              struct {
                FLOAT U;
                FLOAT V;
              } TEXTURE_COORDINATES;
              struct {
                FLOAT X;
                FLOAT Y;
                FLOAT Z; 
              } NORMAL;
            };                   
            if (type == 3) {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;                 
            };
          } DATA[VertexCount];    
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children; 
      }; break;

      case 39: {
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        struct {
          UINT ChildCount;
          chunkTree(ChildCount);
        } Children;       
      }; break;

      case 40: {
        struct {
          FLOAT X;
          FLOAT Y;
          FLOAT Z;
        } POSITION <name="Position (world coordinates)">;
        FLOAT MN;

        char Empty[32];
        char GenName[32]; // generator name

        UINT type;
        FLOAT MN;
        UINT Count;
        FLOAT MN1[Count];      
      }; break;
    }; 
   // } PROPERTIES <name="Properties">;
    checkIdentifier();   
    IDENTIFIER Identifier;
   //
  } CH <name=Name>;
  typedef struct (int arraySize) {
    CH array[arraySize] <optimize=false, name=Name>;
  } CHUNKS;         
  CHUNKS ChunkArray(ChildCount) <name=ChunkName>;

  return 0;
};

string ChunkName(CHUNKS &chunks) {

  if (exists(chunks.array.HEADER))
    switch (chunks.array.HEADER.ID) {
      case 0: return "Empty (id 0): " + chunks.array.HEADER.String; break;
      case 4: return "Road Object Group (id 4): " + chunks.array.HEADER.String; break;
      case 5: return "3d Object (id 5): " + chunks.array.HEADER.String; break;
      case 19: return "Room Group (id 19): " + chunks.array.HEADER.String; break;
      case 24: return "Space (id 24): " + chunks.array.HEADER.String; break;
      case 30: return "Portal (id 30): " + chunks.array.HEADER.String; break;
      case 35: return "Polygons (id 35): " + chunks.array.HEADER.String; break;
      case 37: return "3D data (id 37): " + chunks.array.HEADER.String; break;
      case 40: return "Special object (id 40): " + chunks.array.HEADER.String; 
      default: return "Chunk: (id " + IntToStr(chunks.array.HEADER.ID) + "): " + chunks.array.HEADER.String; 
  } else 
    return "END";
};

string Name(CH &chunk) {
  if (exists(chunk.HEADER))
    switch (chunk.HEADER.ID) {
      case 0: return "Empty (id 0): " + chunk.HEADER.String; break;
      case 4: return "Road Object (id 4): " + chunk.HEADER.String; break;
      case 5: return "3d Object (id 5): " + chunk.HEADER.String; break;
      case 19: return "Room (id 19): " + chunk.HEADER.String; break;
      case 24: return "Space (id 24): " + chunk.HEADER.String; break;
      case 30: return "Portal (id 30): " + chunk.HEADER.String; break;
      case 35: return "Polygons (id 35): " + chunk.HEADER.String; break;
      case 37: return "3D data (id 37): " + chunk.HEADER.String; break;
      case 40: return "Special object (id 40): " + chunk.HEADER.String; break;
      default: return "Chunk: (id " + IntToStr(chunk.HEADER.ID) + "): "  + chunk.HEADER.String;
  }
  else 
    return "END";
}

struct {
  IDENTIFIER Begin <name="BEGIN">;
  while (chunkTree(1) == 0) 
  {
    UINT T <hidden=true>; 
    // pass chunks
    if (T == 222) {  
       FSeek(FTell() - 4);      
       IDENTIFIER End <name="END">;    
       return 1;
    };
  };
} Chunks <name="Data Chunks">;
 