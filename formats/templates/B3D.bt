//------------------------------------------------
//--- 010 Editor v7.0 Binary Template
//
//      File: B3D.bt
//   Authors: Alexandr Evdokimov
//   Version: 0.1
//   Purpose: Hard truck 2 B3D file
//
//   History: 
//    
//   2018.05 v 0.1 initial release 
//
//------------------------------------------------

string IntToStr (uint i) {
  local string s;
  SPrintf(s, "%d", i);
  return s;
} 

void checkToken() {
  while (true) { 
    UINT T <hidden=true>;
    if (T != 444) {
      FSeek(FTell() - 4);
      break; 
    };
  }
}

typedef struct {
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } X;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Y;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Z;
  struct {
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
  } Pos; 
} TRANSFORMATION_MATRIX <name="Transformation matrix">;

typedef enum <uint> {
  Begin_Token = 111,
  End_Token = 222,
  Begin_Chunk_Token = 333,
  Fours_Token = 444,
  End_Chunk_Token = 555
} TOKEN; 

struct {
  char B3D[4] <name="b3D signature">;
  struct {
    UINT FileSize; // 1/4*filesize
    UINT MN; // 6
    UINT MatListDataSize; // 1/4*(materials list data)
    UINT HeaderSectionSize; // 1/4*(materials list data + data sizes block)
    UINT DataSize; // 1/4*(datasize)
  } DataSizes <name = "Data sizes">;
} Header <name="File Header">;

struct {
    UINT MaterialCount <name="Count">;
    typedef struct {
      char String[32] <name="Name">; 
    } MATERIAL <optimize=false, name=MatName>;
    typedef struct (int arraySize) {
      MATERIAL array[arraySize] <optimize=false>;
    } MATERIAL_Array;       
    MATERIAL_Array Materials(MaterialCount) <name="Materials Array">;
} M <name="Material List">;

string MatName(MATERIAL &material) {
  return material.String;
};

UINT chunkTree(UINT ChildCount) {
  typedef struct {
    checkToken(); 
    TOKEN Token <name="Token">;
    struct {
      char String[32] <name="Name">;
      UINT ID <name="Chunk ID">;
    } HEADER <name="Header">;
    //
    //struct {
    switch ( HEADER.ID ) 
    {
        case 0  : {
          UINT type1;
          FLOAT MN; 
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          if (type1 == 20) {
            UINT MN;
            UINT MN;
            UINT MN;
            UINT MN;
            char Name[16];
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            UINT MN;
          };
          if (type1 == 5) {
            char String[32]; 
          } else
          if (type1 == 9) {
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;  
          }
          else 
            if (type1 == 0) {
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN; 
            FLOAT MN; 
          };
          if (type1 != 0 && type1 != 9 && type1 != 5 && type1 != 20)  {
          FLOAT MN;
          FLOAT MN;   
          UINT MN; 
          UINT Count;
          struct { 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
          } K1[Count];  
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;         
          };
        }; break;

        case 1  : {
          BYTE Name1[32];
          char Name2[32];
        }; break;

        case 2  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;


        case 4  : {
          FLOAT MN;
          FLOAT MN;
          char String[32]; //
          UINT MN; //
          FLOAT MN; 
          UINT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;
    
        case 5  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          char GroupName[32]; // name 
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;       
        }; break;

        case 7  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          char GroupName[32]; // name 
          UINT VertexCount <name="Vertex Count">;
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
            FLOAT U;
            FLOAT V;
          } K1[VertexCount];
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;
        }; break;

        case 8  : {
          FLOAT type1;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          UINT Count;
          struct { 
            UINT type2;
            FLOAT MN;
            UINT MN;
            UINT MN;

            UINT CountA;
            if (type2 == 131) {
              struct { 
                UINT MN;
                FLOAT MN;
                FLOAT MN;                
              } H[CountA];                           
            } else
            if (type2 == 129) {
              struct { 
                UINT MN;
              } H[CountA];                           
            } else
            if (type2 == 3) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 176) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 51) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 178) {
              struct { 
                UINT CCount;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN; 
                FLOAT MN;  
              } H[CountA] <optimize=false>;                           
            } else
            if (type2 == 179) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 177) {
              struct { 
                FLOAT MN;
                FLOAT MN;
              } H[CountA];                           
            } else
            if (type2 == 48) {
              struct { 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
                FLOAT MN; 
              } H[CountA];            
            } else {
                if (type2 == 50) {
                   struct { 
                     FLOAT MN;
                     FLOAT MN;
                     FLOAT MN;
                     FLOAT MN; 
                     UINT MN; 
                     UINT MN; 
                   } H[CountA];
                  } else
              UINT L1[CountA] ;
              if (type2 == 2)
                FLOAT L2[CountA*2];                
            }; 
          } K1[Count] <optimize=false>;         
        }; break;

        case 9  : {
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;      
        }; break;

        case 10  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;     
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;             
        }; break;

        case 12  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          UINT MN;
          UINT MN;      
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;             
        }; break;

        case 13  : {
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          UINT type1;
          //if (type1 > 0)
            FLOAT MN1[type1];  
        }; break;

        case 14  : {
          UINT MN;
          UINT MN;
          UINT MN;
          UINT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;  
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;     
        }; break;

        case 18  : {
          UINT MN;
          UINT MN;
          UINT MN;
          FLOAT MN;
          char Space[32];
          char Object[32];
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT MN;
          //UINT type;
          //  UINT Count;
          //if (type == 2)         
          //    struct { 
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //    } K1[Count];
          // else 
          // if (type == 258)
          //    struct { 
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;
          //      FLOAT MN;     
          //    } K2[Count];
          //  else {
          //      struct { 
          //        FLOAT MN;
          //        FLOAT MN;
          //        FLOAT MN;
          //        FLOAT MN;
          //        FLOAT MN;
          //        FLOAT MN;
          //      } K3[Count]; 
          //   };            
          //struct {
          //  UINT ChildCount;
          //  chunkTree(ChildCount);
          //} Children; 
        }; break;
    
        case 19  : {
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;

        case 20  : {
            UINT MN;
            UINT MN;
            UINT MN;
            UINT MN; 
            UINT type1;
            UINT MN;
            UINT MN;
            UINT type2;

            struct {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;                         
            } Y[type1];

            FLOAT A[type2]; 

            //if (type2 != 0 && type2 != 1 && type2 != 2)
           // struct {
           //   UINT ChildCount;
          //    chunkTree(ChildCount);
          //  } Children;                   
        }; break;

        case 21  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN; 
          UINT MN;
          UINT MN;
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;  
        }; break;

        case 23  : {
            UINT MN;
            UINT MN;
            UINT type;
            if (type == 3) {
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;   
           
              UINT CountA;  
                struct {  
                  UINT Count;

                  struct { 
                    FLOAT MN;
                    FLOAT MN;   
                    FLOAT MN;
                  } L[Count];
                                 
                } L[CountA] <optimize=false>;               
            } else
            if (type == 2) {
              FLOAT MN;
              FLOAT MN;
              UINT CountA;  
                struct {  
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;   
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN; 
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;   
                  FLOAT MN;               
                } L[CountA]; 

            } else {
              UINT CountA; 
              struct {    
                UINT Count;
                struct {  
                    FLOAT MN;
                    FLOAT MN;
                    FLOAT MN;                   
                } L[Count];         
              } K1[CountA] <optimize=false>;
            };   
        }; break;

        case 24  : {
            TRANSFORMATION_MATRIX TM;
            UINT MN;
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;    
        }; break;

        case 25  : {
            FLOAT MN;
            UINT MN;
            UINT MN;
            char Name[32]; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;    
        }; break;

        case 28  : {
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;

            UINT Count;
            struct {
              FLOAT type;
              FLOAT MN;
              UINT A;
              UINT B;
              UINT Count;
              if (type == 4294967040) {
                struct {
                  FLOAT MN; 
                  FLOAT MN;
                } E[Count]; 
              } else 
              struct {
                FLOAT MN; 
                FLOAT MN;
                FLOAT MN;
                FLOAT MN;
              } E[Count];
            } Y[Count] <optimize=false>;

            //struct {
            //  UINT ChildCount;
            //  chunkTree(ChildCount);
            //} Children;    
        }; break;

        case 29  : {
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            UINT type; 
            UINT Count;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN; 
            if (type != 3)
              FLOAT MN;           
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;    
        }; break;

        case 30  : {
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            char String[32]; 
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;   
            FLOAT MN;
            FLOAT MN;                   
        }; break;

        case 33  : {
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            TRANSFORMATION_MATRIX TM;
            struct {
              UINT ChildCount;
              chunkTree(ChildCount);
            } Children;  
        }; break;   

        case 34  : {
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            FLOAT MN;
            UINT Count;
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
            } K[Count];
            //struct {
            //  UINT ChildCount;
            //  chunkTree(ChildCount);
            //} Children;  
        }; break; 
 
        case 35  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          UINT type;
          UINT ObjectIndex;
          UINT Count;
          if (type == 3) {
            struct { 
              UINT MN;
              FLOAT MN;
              UINT MN;
              UINT MN;
              UINT Count;
              UINT L[Count];
            } K[Count] <optimize=false>;
          };
          if (type == 2) {
            struct { 
              UINT type;
              FLOAT MN;
              UINT MN;
              UINT MN;
              UINT Count;
              if (type == 49) {
                struct {
                  UINT MN;
                  FLOAT MN;
                } U[Count];
              } else
              if (type == 51) {
                struct {
                  UINT MN;
                  FLOAT MN;
                  FLOAT MN;
                  FLOAT MN;
                }U[Count];
              } else {
                UINT L[Count];
                if (type == 3) {
                  UINT MN;
                  FLOAT MN;
                  FLOAT MN;
                  UINT MN;
                  FLOAT MN;
                  UINT MN;
                };
             };            
            } K[Count] <optimize=false>;
           };
           if (type == 1) {
              struct { 
                UINT type3;
                FLOAT MN;
                UINT MN;
                UINT MN;
                UINT Count;
                if (type3 == 0) {
                  struct {
                    FLOAT MN;
                  } Y[Count];
                } else
                if (type3 == 2) {
                  struct {
                    FLOAT MN;
                    FLOAT MN;
                    FLOAT MN;
                  } Y[Count];
                } else
                struct {
                  UINT MN;
                  FLOAT MN;
                  FLOAT MN; 
                  UINT MN; 
                  if (type3 == 50) {
                    UINT MN; 
                    UINT MN; 
                  } ;   
                } Y[Count];
              } K[Count] <optimize=false>;
          };
        }; break;
 
        case 36  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          char Name1[32];
          char Name2[32];
          UINT type;
          UINT Count;
          if (type == 2) {
            struct { 
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
              FLOAT X;
              FLOAT Y;
              FLOAT Z;
              FLOAT X;
              FLOAT X;
            } K1[Count];
          } else 
          struct { 
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
            FLOAT X;
            FLOAT Y;
            FLOAT Z;
          } K1[Count];
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children;
        }; break;   

    
        case 37  : {
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          FLOAT MN;
          char Name[32];
          UINT type;
          UINT Count;
          if (type == 515) 
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN; 
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN;           
            } K[Count]; 
          if (type == 514) 
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN; 
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN; 
              FLOAT MN;  
              FLOAT MN;           
            } K[Count];  
          if (type == 258) 
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;  
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;  
              FLOAT MN;                 
            } K[Count]; 
          if (type == 2)      
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;                   
            } K[Count];  
          if (type == 3) 
            struct { 
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;
              FLOAT MN;                 
            } K[Count];    
          struct {
            UINT ChildCount;
            chunkTree(ChildCount);
          } Children; 
      }; break;

      case 39: {
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        struct {
          UINT ChildCount;
          chunkTree(ChildCount);
        } Children;       
      }; break;

      case 40: {
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;
        FLOAT MN;

        char Name1[32];
        char Name2[32];

        UINT Count;
        FLOAT MN;
        UINT Count;
        FLOAT MN1[Count];      
      }; break;
    }; 
   // } PROPERTIES <name="Properties">;
    checkToken();   
    TOKEN Token <name="Token">;
   //
  } CH <name=Name>;
  typedef struct (int arraySize) {
    CH array[arraySize] <optimize=false, name=Name>;
  } CHUNKS;         
  CHUNKS ChunkArray(ChildCount) <name=ChunkName>;

  return 0;
};

string ChunkName(CHUNKS &chunks) {
  if (exists(chunks.array.HEADER)) {
   if (chunks.array.HEADER.String == "")
    return "(id " + IntToStr(chunks.array.HEADER.ID) + ")" +" Empty";
   else
    if (chunks.array.HEADER.ID == 24)
      return "Space (id 24): " + chunks.array.HEADER.String;
   else
    if (chunks.array.HEADER.ID == 19)
      return "Room (id 19): " + chunks.array.HEADER.String;
   else
    if (chunks.array.HEADER.ID == 14)
      return "Event (id 14): " + chunks.array.HEADER.String;
   else
    if (chunks.array.HEADER.ID == 5)
      return "Group (id 5): " + chunks.array.HEADER.String;
   else
    return "(id " + IntToStr(chunks.array.HEADER.ID) + ") " + chunks.array.HEADER.String;
  } else 
    return "END";
};

string Name(CH &chunk) {
  if (exists(chunk.HEADER)) {
    if (chunk.HEADER.String == "")
      return "(id " + IntToStr(chunk.HEADER.ID) + ")" + "Chunk: Empty";
    else
    if (chunk.HEADER.ID == 5)
      return "Chunk (id 5): Group: " + chunk.HEADER.String;
    if (chunk.HEADER.ID == 24)
      return "Chunk (id 24): Space: " + chunk.HEADER.String;
    else
      return "(id " + IntToStr(chunk.HEADER.ID) + ") " + "Chunk: " + chunk.HEADER.String;
  } else 
    return "END";
}

struct {
  TOKEN Begin <name="BEGIN">;
  while (chunkTree(1) == 0) 
  {
    UINT T <hidden=true>; 
    // pass chunks
    if (T == 222) {  
       FSeek(FTell() - 4);      
       TOKEN End <name="END">;    
       return 1;
    };
  };
} Chunks <name="Data Chunks">;
 